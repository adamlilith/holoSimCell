##AES
##
#' aggregate a pophist object into genetic populations
#' @param ph the output from forward time sim.  includes a pophist object
#' @param gmap data frame that maps forward time populations to genetic populations
#'
#' @return ph list object with new gpophist (genetic pophist) included as a list element
#' @details This function takes a fine-grained spatio-temporal history of a species generated by holoSimCells forward-time simulator and aggregates demographic populations into genetic populations that can be simulated more tractably
#'
#' @export
pophist.aggregate <- function(ph, gmap=NULL)
{
    if (is.null(ph)) stop("must include output from getpophist")
    if (is.null(ph$pophist)) stop("there needs to be a correct pophist in the list 'ph'")
    if (is.null(gmap))
    {
        gh = ph$coalhist
    }    else   { #do the aggregation
        gpophist = merge(ph$pophist,gmap[,c("pop","gpop")])
        gh=do.call(rbind,lapply(unique(sort(ph$coalhist$time)),function(tm)
        {
            ch=ph$coalhist[ph$coalhist$time==tm,]           
            gch=data.frame(time=NA,src=NA,snk=NA,mv_sz=NA,gp_sz=NA)[-1,]
            for (i in 1:nrow(ch))
            {
                gsnk=gmap$gpop[gmap$pop==ch$snk[i]] #genetic sinks at this time (reverse time)
                gsrc=gmap$gpop[gmap$pop==ch$src[i]] #genetics sources at this time  (reverse time)
                if (gsnk!=gsrc) ##if events are within same gpop do nothing, otherwise do this
                {
                    mv_sz = ph$Nvecs[ch$src[i],ch$time[i]+1] #i+1 cause value is zero at time i
                    gp_sz = sum(ph$Nvecs[gmap$pop[gmap$gpop==gsrc],ch$time[i]])+
                        ph$Nvecs[ch$src[i],ch$time[i]+1]-
                        ph$Nvecs[ch$src[i],ch$time[i]]

                    prop = mv_sz/gp_sz
                    gch <- rbind(gch,cbind(time=ch$time[i],src=gsrc,snk=gsnk,mv_sz=mv_sz,gp_sz=gp_sz))
                    
                }
                
            }

            if (nrow(gch)>0) {
                normval=with(gch,aggregate(cbind(mv_sz=mv_sz,gp_sz=gp_sz),list(time=time,src=src,snk=snk),sum))
                normval$time <- as.numeric(as.character(normval$time))
                normval$src <- as.numeric(as.character(normval$src))
                normval$snk <- as.numeric(as.character(normval$snk))
                } else normval <- NULL
            normval$prop=normval$mv_sz/normval$gp_sz
            normval$prop[is.na(normval$prop)] <- 1.0  #if the population immediately extincts prop is a NaN (0/0). this fixes
            normval
        }))
        gh = gh[order(-gh$time,gh$snk),]
        rownames(gh) <- 1:nrow(gh)
    }
    ph$coalhist <- gh[,c(1,2,3,6)]

    #now the pophist object
    poph <- gmap[,-1]
    names(poph)[1] <- "pop"
    poph <- with(poph,aggregate(cbind(row=row,col=col),list(pop=pop),mean))
#    poph <- merge(poph,l$coalhist,by.y="src",by.x="pop",all=T)[,1:5]
#    names(poph) <- c("pop","row","col","arrive","source")
    pophist <- merge(ph$pophist,gmap)
    gpophist <- do.call(rbind,lapply(unique(pophist$gpop),function(gp)
    {
        p <- pophist[pophist$gpop==gp,]
        print(p)
        if (nrow(p)>0)
        {
            ret <- NULL  #data.frame(pop=NA,arrive=NA,source=NA)[-1,]
            for (a in unique(p$arrive))
                for (s in unique(p$source))
                {
                    if (is.na(s)) src <- NA else src <- gmap[gmap$pop==s,"gpop"]
                    print(paste("gp",gp,"a",a,"s",s,"src",src))

                    if (!is.na(src)[1])
                        if (src!=gp)
                        {
                            print("adding line")
                            ret <- rbind(ret,
                                         data.frame(pop=gp,arrive=a,source=src))
                        }
                }
            ret
        } else {NULL}
        
    }))
    
    
###now redo Nvecs
    nv <- aggregate(ph$Nvecs,list(gpop=gmap$gpop),sum)
    rownames(nv) <- as.character(nv$gpop)
    nv <- nv[,-1]
    ph$Nvecs <- nv
###now redo hab_suit (through taking means)
    ph$aggregate_hab_suit <- t(aggregate(t(ph$hab_suit$hab_suit),list(gpop=gmap$gpop),mean))
###now redo tmat
    ysz <- ph$struct["sz"]*length(unique(ph$pophist[ph$pophist$pop %in% gmap[gmap$gpop==1,"pop"],"row"]))
    xsz <- ph$struct["sz"]*length(unique(ph$pophist[ph$pophist$pop %in% gmap[gmap$gpop==1,"pop"],"col"]))
 
    tmat <- integratedMigMat(landx=ceiling(max(gmap$col)/xsz),landy=ceiling(max(gmap$row)/ysz),
                             xnum=5,ynum=5,ysz=ysz,xsz=xsz,
                             sshp=ph$struct["shortshape"],ssc=ph$struct["shortscale"],mix=ph$struct["mix"],
                             nmean=ph$struct["longmean"],nvar=ph$struct["longmean"]^2)
    ph$aggregate_tmat <- tmat
    ph$gmap <- gmap

    
    ph
}





#' make a genetic subset map for rectangular landscape
#' @param pophist a demographic population history
#' @param xnum number of columns to aggregate
#' @param ynum number of rows to aggregate
#'
#' @return a gmap object used for pophist.aggregate
#' @details If the size of the landscape in pophist is not evenly divisible by xnum and ynum, "remainder" cells on the top and righthand sides of the landscape will be included in genetic clusters.  As a result the numbers of cells per cluster will vary
#' 
make.gmap <- function(pophist,xnum=2,ynum=2)
{
 ##   remain.right = max(pophist$col) %% xnum
 ##   remain.top = max(pophist$row) %% ynum

    gm=expand.grid(startx=seq(1,max(pophist$col),by=xnum),
                   starty=seq(1,max(pophist$row),by=ynum))
    gm$stopx=lag(gm$startx)+xnum-1
    gm$stopy=lag(gm$starty)+ynum-1
    gm$pop=1:dim(gm)[1]
    gpops=do.call(rbind,lapply(1:dim(gm)[1],function(i) #go through the gpops and find all the pops that fit in each
    {
        tmp = with(pophist,pophist[(col<=gm$stopx[i])&
                                   (col>=gm$startx[i])&
                                   (row<=gm$stopy[i])&
                                   (row>=gm$starty[i]),])
        tmp$gpop=gm$pop[i]
        tmp
    }))
    
    gpops[order(gpops$pop),c("pop","gpop","col","row")]
}
