}
demename <- c()
for(popu in 1:length(demelist)) {
if(!newID[popu] %in% sample_pops) {
demename[popu] <- paste0("unsamp-",popu)
} else {
demename[popu] <- l$sampdf$abbrev[l$sampdf$cell %in% gmap$pop[gmap$gpop == oldID[popu]]]
}
}
names(demelist) <- demename
demes <- do.call(fscSettingsDemes, demelist)
#  pop_info <- fscPopInfo(pop.size = pop_size, sample.size = sample_size, growth.rate = growth_rate)
##################################################
# PARAMETERS FOR SIMULATED LOCI
##################################################
#if(loc_parms$marker == "snp") {
#  locus_params <- fscLocusParams(locus.type = as.character(loc_parms$marker), num.loci = loc_parms$nloci, mut.rate = loc_parms$seq_length*loc_parms$mu)
#  attr(locus_params, "opts") <- "-s 0"
#} else if(loc_parms$marker == "dna") {
#  locus_params <- fscLocusParams(locus.type = as.character(loc_parms$marker), sequence.length = loc_parms$seq_length, num.chrom = loc_parms$nloci, mut.rate = loc_parms$mu)
#} else if(loc_parms$marker == "msat") {
#  locus_params <- fscLocusParams(locus.type = as.character(loc_parms$marker), num.loci = 1, num.chrom = loc_parms$nloci, mut.rate = loc_parms$mu)
#}
###!### This stuff is new!!
if(loc_parms$marker == "snp") {
genetics <- fscSettingsGenetics(fscBlock_snp(sequence.length = loc_parms$seq_length, mut.rate = loc_parms$mu), num.chrom = loc_parms$nloci)
} else {
stop("runFSC_step is only built for SNP data (at the moment)")
}
##################################################
# HISTORY OF DEMOGRAPHIC EVENTS
##################################################
usemigmat <- 0
ev <- 1
for(G in 0:ngens) {
tmp_pops <- coalhist[which(coalhist$time == G),]
#tmp_pops <- FSCpops[which(FSCpops$arrive == G),]
tmp_leaving <- c()
if(length(tmp_pops[,1]) > 0) {
for(fp in 1:length(tmp_pops[,1])) {
if(!is.na(tmp_pops$snk[fp])) {
##!## Adding this if statement to check whether this is the ORIGINAL founding event - JDR 4/1/2020
if(tmp_pops$prop[fp] == 1) {
allevents[ev,] <- c(G-1, tmp_pops$src[fp], tmp_pops$src[fp], 0, as.numeric(found_Ne)/as.numeric(pop_size[tmp_pops$src[fp]+1]), 0, usemigmat)
ev <- ev+1
tmp_leaving <- c(tmp_leaving, tmp_pops$src[fp]+1)
}
##!## Adding in tmp_pops$prop for migrant proportion - JDR 4/1/2020
allevents[ev,] <- c(G, tmp_pops$src[fp], tmp_pops$snk[fp], tmp_pops$prop[fp], 1, 0, usemigmat+1)
ev <- ev+1
}
}
migmat[[usemigmat+2]] <- migmat[[usemigmat+1]]
migmat[[usemigmat+2]][tmp_leaving,] <- 0
migmat[[usemigmat+2]][,tmp_leaving] <- 0
usemigmat <- usemigmat + 1
rm(tmp_pops)
rm(tmp_leaving)
}
}
migmat[[length(migmat)+1]] <- migmat[[length(migmat)]]
migmat[[length(migmat)]][migmat[[length(migmat)]] > 0] <- 0
nomig_migmat <- length(migmat)-1
migration <- do.call(fscSettingsMigration, migmat)
##################################################
# COMBINE EVERYTHING, SORT, AND RUN FSC
##################################################
allevents <- allevents[order(allevents$time, allevents$new_mig, allevents$prop_m, allevents$source),]
###!### New stuff here!!
eventlist <- vector("list", nrow(allevents))
for(ev in 1:nrow(allevents)) {
eventlist[[ev]] <- fscEvent(event.time = allevents$time[ev], source = allevents$source[ev], sink = allevents$sink[ev], prop.migrants = allevents$prop_m[ev], new.size = allevents$new_size[ev], new.growth = allevents$new_growth[ev], migr.mat = allevents$new_mig[ev])
}
eventlist[[length(eventlist)+1]] <- fscEvent(event.time = ngens, source = newID[which(simhist[,1] > 0)], sink = newID[which(simhist[,1] > 0)], prop.migrants = 0, new.size = 1, new.growth = 0, migr.mat = nomig_migmat)
#hist_ev <- fscHistEv(num.gen = allevents$time, source.deme = allevents$source, sink.deme = allevents$sink, prop.migrants = allevents$prop_m, new.sink.size = allevents$new_size, new.sink.growth = allevents$new_growth, new.mig.mat = allevents$new_mig)
#hist_ev1 <- fscHistEv(num.gen = ngens, source.deme = newID[which(simhist[,1] > 0)], sink.deme = newID[which(simhist[,1] > 0)], prop.migrants = 0, new.sink.size = 1, new.sink.growth = 0, new.mig.mat = "nomig")
if(length(newID[which(simhist[,1] > 0)]) == 1) {
eventlist[[length(eventlist)+1]] <- fscEvent(event.time = preLGMparms$preLGM_t[1], source = newID[which(simhist[,1] > 0)], sink = newID[which(simhist[,1] > 0)], prop.migrants = 0, new.size = round(preLGMparms$preLGM_Ne/preLGMparms$ref_Ne,5), new.growth = 0, migr.mat = nomig_migmat)
#hist_ev2 <- fscHistEv(num.gen = preLGMparms$preLGM_t[1], newID[which(simhist[,1] > 0)], sink.deme = newID[which(simhist[,1] > 0)], prop.migrants = 0, new.sink.size = round(preLGMparms$preLGM_Ne/preLGMparms$ref_Ne,5), new.sink.growth = 0, new.mig.mat = "nomig")
#hist_ev <- rbind(hist_ev, hist_ev1, hist_ev2)
} else {
arb.preLGM.pop <- newID[which(simhist[,1] > 0)][1]
for(rem in 2:(length(which(simhist[,1] > 0))-1)) {
eventlist[[length(eventlist)+1]] <- fscEvent(event.time = preLGMparms$preLGM_t[1]-1, source = newID[which(simhist[,1] >0)][rem], sink = arb.preLGM.pop, prop.migrants = 1, new.size = 1, new.growth = 0, migr.mat = nomig_migmat)
}
eventlist[[length(eventlist)+1]] <- fscEvent(event.time = preLGMparms$preLGM_t[1], source = arb.preLGM.pop, sink = arb.preLGM.pop, prop.migrants = 0, new.size = round(preLGMparms$preLGM_Ne/preLGMparms$ref_Ne,5), new.growth = 0, migr.mat = nomig_migmat)
#hist_ev2 <- fscHistEv(num.gen = preLGMparms$preLGM_t[1]-1, source.deme = newID[which(simhist[,1] > 0)][-1], sink.deme = arb.preLGM.pop, prop.migrants = 1, new.sink.size = 1, new.sink.growth = 0, new.mig.mat = "nomig")
#hist_ev3 <- fscHistEv(num.gen = preLGMparms$preLGM_t[1], source.deme = arb.preLGM.pop, sink.deme = arb.preLGM.pop, prop.migrants = 0, new.sink.size = round(preLGMparms$preLGM_Ne/preLGMparms$ref_Ne,5), new.sink.growth = 0, new.mig.mat = "nomig")
#hist_ev <- rbind(hist_ev, hist_ev1, hist_ev2, hist_ev3)
}
events <- do.call(fscSettingsEvents, eventlist)
#fscout <- fastsimcoal(label = label, pop.info = pop_info, locus.params = locus_params, mig.rates = migmat, hist.ev = hist_ev, num.cores = num_cores, delete.files = delete_files, exec = exec)
###!### This is new!!
p <- fscWrite(demes = demes, genetics = genetics, events = events, migration = migration, label = label, use.wd = TRUE)
p <- fscRun(p, all.sites = FALSE, inf.sites = FALSE, no.arl.output = FALSE, dna.to.snp = TRUE, quiet = FALSE, num.cores = 6, exec = exec)
out <- fscReadArp(p)
#Function from Eric Archer's strataG fscTutorial() markdown
sampleOnePerLocus <- function(mat) {
# Extract the SNP names from the matrix column names
snp.name <- colnames(mat[, -(1:2)])
# Extract the chromosome name (starts with "C" and is followed by numbers)
#   from the SNP names
chrom.names <- regmatches(snp.name, regexpr("^C[[:digit:]]+", snp.name))
# Choose one SNP per chromosome
one.per.loc <- tapply(colnames(mat[, -(1:2)]), chrom.names, sample, size = 1)
# Return matrix of
mat[, c("id", "deme", one.per.loc)]
}
fscout <- sampleOnePerLocus(out)
###!### JDR 3/25/2020
#I don't think we really want this formatted as a gtypes object anymore :(
###!###
#Naming strata prior to output - this is no longer needed with new strataG!!  - JDR 4/3/2020
#FSCid <- sapply(strsplit(fscout@data$ids,"_"), function(x){x[1]})
#FSCgridid <- plyr::mapvalues(FSCid,newID,oldID,warn_missing=FALSE)
#Then map these old ID's back to the abbreviation of the sampled population
#FSCabbrev <- plyr::mapvalues(FSCgridid,l$sampdf$cell,l$sampdf$abbrev)
#fscout@data$strata <- FSCabbrev
#fscout@data$ids <- paste0(fscout@data$strata, "_", c(1:length(fscout@data[,1])))
fscout
}
out <- runFSC_step_agg2(ph = ph2,				#A new pophist object - (pophist, Nvecs, tmat, struct, hab_suit, coalhist)
l = landscape, 			#A new landscape object - (details, occupied, empty, sampled, hab_suit, sumrast, samplocsrast, samplocs)
sample_n = 14,		#Number of sampled individuals per population
preLGMparms = preLGMparms,		#This has parms for the refuge, preLGM size and timing
label = "test_agg",			#Label for FSC simulation files
delete_files = TRUE,	#Logical - clear out .par, .arp, and other FSC outputs?
num_cores = 1,			#Number of processors to use for FSC
exec = "fsc25",			#Executable for FSC (needs to be in a folder in the system $PATH)
loc_parms = loc_parms2,		#Vector of locus parameters
found_Ne = parms$found_Ne,			#Founding population size, required for STEP change model
gmap = gmap)
#Use function in FixCoalHist.R to fix the coalescent history
phFIXED <- fixcoalhist(ph=ph2)
warnings()
#With smaller K, some populations have very very low N at the end of the simulation
#In those cases, we need to inflate N a bit for the coalescent simulation
ph2$Nvecs[ph2$Nvecs[,702] > 0 & ph2$Nvecs[,702] < 1,702] <- 1
#Run the coalescent simulation
setwd(simdir)
#Use function in FixCoalHist.R to fix the coalescent history
phFIXED <- fixcoalhist(ph=ph2)
out <- runFSC_step_agg2(ph = phFIXED,				#A new pophist object - (pophist, Nvecs, tmat, struct, hab_suit, coalhist)
l = landscape, 			#A new landscape object - (details, occupied, empty, sampled, hab_suit, sumrast, samplocsrast, samplocs)
sample_n = 14,		#Number of sampled individuals per population
preLGMparms = preLGMparms,		#This has parms for the refuge, preLGM size and timing
label = "test_agg",			#Label for FSC simulation files
delete_files = TRUE,	#Logical - clear out .par, .arp, and other FSC outputs?
num_cores = 1,			#Number of processors to use for FSC
exec = "fsc25",			#Executable for FSC (needs to be in a folder in the system $PATH)
loc_parms = loc_parms2,		#Vector of locus parameters
found_Ne = parms$found_Ne,			#Founding population size, required for STEP change model
gmap = gmap)
dim(out)
table(out[,-c(1,2)])
apply(out[,-c(1,2)], 2, FUN=function(x) dim(table(x)))
out$C0800B1_SNP_L52.1
SNPnum <- get.gSum(fscout)
SNPnum <- get.gSum(out)
get.gSum()
get.gSum
outdir <- "~/Desktop"
simdir <- outdir
parms <- drawParms(control = system.file("extdata/csv","priors.csv",package="holoSimCell"))
parms$seq_length <- 80
parms$mu <- 1e-8
loc_parms <- data.frame(marker = "snp",
nloci = parms$nloci,
seq_length = parms$seq_length,
mu = parms$mu)
loc_parms2 <- loc_parms     #Will use this object for simulations, increase # of loci until we get loc_parms$nloci SNPs
loc_parms2$nloci <- round(loc_parms2$nloci*1.25) 	#!!# #Simulate more loci than needed to account for monomorphic sites
preLGMparms <- data.frame(preLGM_t = parms$preLGM_t/parms$G,		#Time / GenTime
preLGM_Ne = parms$preLGM_Ne,
ref_Ne = parms$ref_Ne)
parms_out <- as.data.frame(c(ph$struct[which(!names(ph$struct) %in% names(parms))], parms))
#With smaller K, some populations have very very low N at the end of the simulation
#In those cases, we need to inflate N a bit for the coalescent simulation
ph2$Nvecs[ph2$Nvecs[,702] > 0 & ph2$Nvecs[,702] < 1,702] <- 1
#Run the coalescent simulation
setwd(simdir)
#Use function in FixCoalHist.R to fix the coalescent history
phFIXED <- fixcoalhist(ph=ph2)
out <- runFSC_step_agg2(ph = phFIXED,				#A new pophist object - (pophist, Nvecs, tmat, struct, hab_suit, coalhist)
l = landscape, 			#A new landscape object - (details, occupied, empty, sampled, hab_suit, sumrast, samplocsrast, samplocs)
sample_n = 14,		#Number of sampled individuals per population
preLGMparms = preLGMparms,		#This has parms for the refuge, preLGM size and timing
label = "test_agg",			#Label for FSC simulation files
delete_files = TRUE,	#Logical - clear out .par, .arp, and other FSC outputs?
num_cores = 1,			#Number of processors to use for FSC
exec = "fsc25",			#Executable for FSC (needs to be in a folder in the system $PATH)
loc_parms = loc_parms2,		#Vector of locus parameters
found_Ne = parms$found_Ne,			#Founding population size, required for STEP change model
gmap = gmap)
dim(out)
apply(out[,-c(1,2)],2,FUN=function(x) dim(table(x)))
apply(out[,-c(1,2)],2,FUN=function(x) dim(table(x))) -> SNPperloc
sum(SNPperloc == 2)
allele_per_loc <- apply(out[,-c(1,2)], 2, FUN=function(x) dim(table(x)))
sum(allele_per_loc == 2)
which(allele_per_loc == 1)
out[,which(allele_per_loc == 1)+2]
parms$nloci
#Some loci are not variable... still need to check for this
allele_per_loc <- apply(out[,-c(1,2)], 2, FUN=function(x) dim(table(x)))
#Some loci are not variable... still need to check for this
allele_per_loc <- apply(out[,-c(1,2)], 2, FUN=function(x) dim(table(x)))
sum(allele_per_loc == 2)
var_loc_cols <- which(allele_per_loc == 2) + 2
lenght(var_loc_cols)
length(var_loc_cols)
FINALout <- out[,c(1,2,sample(var_loc_cols,parms$nloci,replace = FALSE))]
dim(FINALout)
sum(apply(FINALout[,-c(1,2)], 2, FUN=function(x) dim(table(x))) == 2)
out <- runFSC_step_agg2(ph = phFIXED,				#A new pophist object - (pophist, Nvecs, tmat, struct, hab_suit, coalhist)
l = landscape, 			#A new landscape object - (details, occupied, empty, sampled, hab_suit, sumrast, samplocsrast, samplocs)
sample_n = 14,		#Number of sampled individuals per population
preLGMparms = preLGMparms,		#This has parms for the refuge, preLGM size and timing
label = "test_agg",			#Label for FSC simulation files
delete_files = TRUE,	#Logical - clear out .par, .arp, and other FSC outputs?
num_cores = 1,			#Number of processors to use for FSC
exec = "fsc25",			#Executable for FSC (needs to be in a folder in the system $PATH)
loc_parms = loc_parms2,		#Vector of locus parameters
found_Ne = parms$found_Ne,			#Founding population size, required for STEP change model
gmap = gmap)
#library(holoSimCell)
devtools::load_all()
rownames(popmap) <- popmap[,1]
table(popmap[gsub("fp","",names(imputed)),2])
imputed.pruned=imputed[,-which(gsub("fp","",names(imputed))%in%popmap[popmap$abbrev=="Michigan","id"])]
imputed.pruned=imputed.pruned[,-which(gsub("fp","",names(imputed.pruned))%in%popmap[popmap$abbrev=="UNK","id"])]
imputed.pruned=imputed.pruned[,-which(gsub("fp","",names(imputed.pruned))%in%popmap[popmap$abbrev=="MO1","id"])]
imputed.pruned=imputed.pruned[,-which(gsub("fp","",names(imputed.pruned))%in%popmap[popmap$abbrev=="ON1","id"])]
imputed.pruned=imputed.pruned[,-which(gsub("fp","",names(imputed.pruned))%in%popmap[popmap$abbrev=="VA1","id"])]
imputed.pruned=imputed.pruned[,-which(gsub("fp","",names(imputed.pruned))%in%popmap[popmap$abbrev=="MB1","id"])]
removes <- c()
popids <- popmap[gsub("fp","",names(imputed.pruned)),2]
table(popids)
for (a in unique(popids))
{
if (sum(popids==a)>14)
{
removes <- c(removes,sample(which(popids==a),1))
}
}
imputed.pruned <- imputed.pruned[,-1*removes]
poptbl <- table(popmap[gsub("fp","",names(imputed.pruned)),2])
samppts <- pts[pts$abbrev %in% names(poptbl),]
##this should produce a landscape with (x,y) _square_ cells that also have
##21empirical samples in separate grid cells (otherwise need to figure out something else)
## ashland is a stored R object as well
if (!exists("ashland"))
{
ashland <- def_grid_pred(pred=ashpred[,,701:1],samppts=samppts,init.ext=c(40,36),keep.thresh=0.05)
}
landscape <- ashland
###seed is based on time in seconds and the number of characters in the library path
###
###
sec=as.numeric(Sys.time())-1500000000
lp= as.numeric(as.character(nchar(paste(.libPaths(), collapse = " "))))
slp <- as.integer(floor(sec*lp))
set.seed(as.integer(sec))
ph = getpophist2.cells(hab_suit=landscape,
refs=(5),
refsz=100,
mix=0.001,  #note how small.
shortscale=6,  # scale parameter of weibull with shape below
shortshape=1, #weibull shape
longmean=75,  # mean of normal with sd = longmean
sz=150) #size of a cell (same units as longmean and shortscale)
gmap=make.gmap(ph$pophist,
xnum=2, #number of cells to aggregate in x-direction
ynum=2) #number of aggregate in the y-direction
ph2 <- pophist.aggregate(ph,gmap=gmap)
phOLD <- ph
ph <- ph2
l <- landscape
num_cores <- 1
label <- "NewTest"
exec <- "fsc26"
sample_n <- 14
found_Ne <- 50
outdir <- "~/Desktop"
simdir <- outdir
parms <- drawParms(control = system.file("extdata/csv","priors.csv",package="holoSimCell"))
parms$seq_length <- 80
parms$mu <- 1e-8
loc_parms <- data.frame(marker = "snp",
nloci = parms$nloci,
seq_length = parms$seq_length,
mu = parms$mu)
loc_parms2 <- loc_parms     #Will use this object for simulations, increase # of loci until we get loc_parms$nloci SNPs
loc_parms2$nloci <- round(loc_parms2$nloci*1.25) 	#!!# #Simulate more loci than needed to account for monomorphic sites
preLGMparms <- data.frame(preLGM_t = parms$preLGM_t/parms$G,		#Time / GenTime
preLGM_Ne = parms$preLGM_Ne,
ref_Ne = parms$ref_Ne)
parms_out <- as.data.frame(c(ph$struct[which(!names(ph$struct) %in% names(parms))], parms))
#With smaller K, some populations have very very low N at the end of the simulation
#In those cases, we need to inflate N a bit for the coalescent simulation
ph2$Nvecs[ph2$Nvecs[,702] > 0 & ph2$Nvecs[,702] < 1,702] <- 1
phOLD <- ph
ph <- ph2
l <- landscape
num_cores <- 1
label <- "NewTest"
exec <- "fsc26"
sample_n <- 14
found_Ne <- 50
exec <- "fsc25"
############################################################
#Error checks
if(is.null(found_Ne)) {
stop("Must specify founding Ne if using the STEP change growth model")
}
#Run the coalescent simulation
setwd(simdir)
#Use function in FixCoalHist.R to fix the coalescent history
phFIXED <- fixcoalhist(ph=ph2)
#Solution for event histories that don't fully coalesce
fixcoalhist <- function(ph = NULL) {
finalcoaltime <- c()
for(pop in unique(ph$coalhist$src)) {
finalcoaltime[pop] <- min(ph$coalhist$time[ph$coalhist$src == pop])
coalhistrows <- which(ph$coalhist$time == finalcoaltime[pop] & ph$coalhist$src == pop)
#print(paste("Population -",pop, "has", length(coalhistrows), "'final' coalescent events"))
if(length(coalhistrows) > 1) {
tmp <- ph$coalhist[coalhistrows,]
replacewith <-c()
for(x in 1:length(coalhistrows)) {
replacewith[x] <- ph$coalhist$prop[coalhistrows[x]]/sum(ph$coalhist$prop[coalhistrows[1:x]])
}
ph$coalhist$prop[coalhistrows] <- replacewith
rm(tmp, replacewith)
}
rm(coalhistrows)
}
ph
}
#Use function in FixCoalHist.R to fix the coalescent history
phFIXED <- fixcoalhist(ph=ph2)
############################################################
#Create objects used downstream as FSC inputs
#Initialize objects for FSC
pops <- ph$pophist
simhist <- ph$Nvecs
tmat <- ph$tmat
struct <- ph$struct
coalhist <- ph$coalhist
migmat <- vector("list", 1)
#migmat[[1]] <- round(tmat,5)
migmat[[1]] <- tmat
diag(migmat[[1]]) <- 0
allevents <- data.frame(time=NA, source = NA, sink = NA, prop_m = NA, new_size = NA, new_growth=NA, new_mig = NA)
#Remove them from the migration matrix
#empty_pops <- sort(unique(c(l$empty, which(rowSums(simhist) == 0))))
#empty_pops <- l$empty
#empty_pops <- sort(unique(c(l$empty, pops$pop[!pops$pop %in% coalhist$src & !pops$pop %in% coalhist$snk & !pops$pop %in% l$empty])))
#empty_pops2 <- sort(unique(c(l$empty, which(rowSums(simhist) == 0))))    #Don't allow migration with populations that went extinct!
#New Definition of empty populations... JDR 4/1/2020
empty <- rep(FALSE, nrow(gmap))
empty[l$empty] <- TRUE
empty_gpops <- sort(unique(c(
gmap$gpop[!gmap$gpop %in% gmap$gpop[empty == FALSE]],
which(rowSums(ph2$Nvecs) == 0),
gmap$gpop[!gmap$gpop %in% coalhist$src & !gmap$gpop %in% coalhist$snk])))
if(length(empty_gpops) > 0) {
simhist <- simhist[-empty_gpops,]
#migmat[[1]][empty_gpops,] <- 0		#Turns migration off for all empty pops, and any pops that went extinct (e.g., GoM populations)
#migmat[[1]][,empty_gpops] <- 0
migmat[[1]] <- migmat[[1]][-empty_gpops,]
migmat[[1]] <- migmat[[1]][,-empty_gpops]
}
############################################################
#Build objects with IDs fixed to account for empty populations and the different starting index (0 for FSC, 1 for forward sim)
#Correct arrival times so you're thinking backwards in time
#Using the new coalhist and landscape objects
ngens <- struct["maxtime"]
oldID <- sort(unique(c(coalhist$src, which(ph$Nvecs[,1] > 0))))
newID <- c(1:length(oldID))-1
coalhist$snk <- plyr::mapvalues(coalhist$snk, oldID, newID, warn_missing=FALSE)
coalhist$src <- plyr::mapvalues(coalhist$src, oldID, newID, warn_missing=FALSE)
coalhist$time <- ngens - coalhist$time
##################################################
# POPULATION INFORMATION
##################################################
#Definitions for pop.info
#h <- struct["xdim"]*struct["ydim"]
h <- max(gmap$gpop)
pop_size <- simhist[,length(simhist[1,])]
pop_size[pop_size == 0] <- 500			#!# What should we do here?  set to 1?  Set to K?  Set to max attained in this pop?  Can't be 0!!
#Sample size
sample_size <- rep(0,h)
#Growth rate = 0
growth_rate <- rep(0,h)
if(length(empty_gpops > 0)) {
sample_size <- sample_size[-empty_gpops]
growth_rate <- growth_rate[-empty_gpops]
}
##!## Slight change here... map first to the gpop column of the gmap object, then to the FSC id (old, new) - JDR 4/1/2020
sample_ids <- plyr::mapvalues(l$sampled, gmap$pop, gmap$gpop, warn_missing=FALSE)
sample_pops <- plyr::mapvalues(sample_ids, oldID, newID, warn_missing=FALSE)
sample_size[sample_pops] <- sample_n
###!### THIS STUFF IS NEW!!
demelist <- vector("list",length(sample_size))
for(p in 1:length(sample_size)) {
demelist[[p]] <- fscDeme(deme.size = pop_size[p], sample.size = sample_size[p], sample.time = 0, inbreeding = 0, growth = growth_rate[p])
}
demename <- c()
for(popu in 1:length(demelist)) {
if(!newID[popu] %in% sample_pops) {
demename[popu] <- paste0("unsamp-",popu)
} else {
demename[popu] <- l$sampdf$abbrev[l$sampdf$cell %in% gmap$pop[gmap$gpop == oldID[popu]]]
}
}
names(demelist) <- demename
demes <- do.call(fscSettingsDemes, demelist)
demes
sampled_pops
sample_pops
demes[57,]
demes[58,]
##!## Slight change here... map first to the gpop column of the gmap object, then to the FSC id (old, new) - JDR 4/1/2020
sample_ids <- plyr::mapvalues(l$sampled, gmap$pop, gmap$gpop, warn_missing=FALSE)
sample_pops <- plyr::mapvalues(sample_ids, oldID, newID, warn_missing=FALSE)
sample_size[sample_pops+1] <- sample_n
###!### THIS STUFF IS NEW!!
demelist <- vector("list",length(sample_size))
for(p in 1:length(sample_size)) {
demelist[[p]] <- fscDeme(deme.size = pop_size[p], sample.size = sample_size[p], sample.time = 0, inbreeding = 0, growth = growth_rate[p])
}
demename <- c()
for(popu in 1:length(demelist)) {
if(!newID[popu] %in% sample_pops) {
demename[popu] <- paste0("unsamp-",popu)
} else {
demename[popu] <- l$sampdf$abbrev[l$sampdf$cell %in% gmap$pop[gmap$gpop == oldID[popu]]]
}
}
names(demelist) <- demename
demes <- do.call(fscSettingsDemes, demelist)
demes[58,]
###!### This stuff is new!!
if(loc_parms$marker == "snp") {
genetics <- fscSettingsGenetics(fscBlock_snp(sequence.length = loc_parms$seq_length, mut.rate = loc_parms$mu), num.chrom = loc_parms$nloci)
} else {
stop("runFSC_step is only built for SNP data (at the moment)")
}
##################################################
# HISTORY OF DEMOGRAPHIC EVENTS
##################################################
usemigmat <- 0
ev <- 1
for(G in 0:ngens) {
tmp_pops <- coalhist[which(coalhist$time == G),]
#tmp_pops <- FSCpops[which(FSCpops$arrive == G),]
tmp_leaving <- c()
if(length(tmp_pops[,1]) > 0) {
for(fp in 1:length(tmp_pops[,1])) {
if(!is.na(tmp_pops$snk[fp])) {
##!## Adding this if statement to check whether this is the ORIGINAL founding event - JDR 4/1/2020
if(tmp_pops$prop[fp] == 1) {
allevents[ev,] <- c(G-1, tmp_pops$src[fp], tmp_pops$src[fp], 0, as.numeric(found_Ne)/as.numeric(pop_size[tmp_pops$src[fp]+1]), 0, usemigmat)
ev <- ev+1
tmp_leaving <- c(tmp_leaving, tmp_pops$src[fp]+1)
}
##!## Adding in tmp_pops$prop for migrant proportion - JDR 4/1/2020
allevents[ev,] <- c(G, tmp_pops$src[fp], tmp_pops$snk[fp], tmp_pops$prop[fp], 1, 0, usemigmat+1)
ev <- ev+1
}
}
migmat[[usemigmat+2]] <- migmat[[usemigmat+1]]
migmat[[usemigmat+2]][tmp_leaving,] <- 0
migmat[[usemigmat+2]][,tmp_leaving] <- 0
usemigmat <- usemigmat + 1
rm(tmp_pops)
rm(tmp_leaving)
}
}
migmat[[length(migmat)+1]] <- migmat[[length(migmat)]]
migmat[[length(migmat)]][migmat[[length(migmat)]] > 0] <- 0
nomig_migmat <- length(migmat)-1
migration <- do.call(fscSettingsMigration, migmat)
##################################################
# COMBINE EVERYTHING, SORT, AND RUN FSC
##################################################
allevents <- allevents[order(allevents$time, allevents$new_mig, allevents$prop_m, allevents$source),]
###!### New stuff here!!
eventlist <- vector("list", nrow(allevents))
for(ev in 1:nrow(allevents)) {
eventlist[[ev]] <- fscEvent(event.time = allevents$time[ev], source = allevents$source[ev], sink = allevents$sink[ev], prop.migrants = allevents$prop_m[ev], new.size = allevents$new_size[ev], new.growth = allevents$new_growth[ev], migr.mat = allevents$new_mig[ev])
}
eventlist[[length(eventlist)+1]] <- fscEvent(event.time = ngens, source = newID[which(simhist[,1] > 0)], sink = newID[which(simhist[,1] > 0)], prop.migrants = 0, new.size = 1, new.growth = 0, migr.mat = nomig_migmat)
if(length(newID[which(simhist[,1] > 0)]) == 1) {
eventlist[[length(eventlist)+1]] <- fscEvent(event.time = preLGMparms$preLGM_t[1], source = newID[which(simhist[,1] > 0)], sink = newID[which(simhist[,1] > 0)], prop.migrants = 0, new.size = round(preLGMparms$preLGM_Ne/preLGMparms$ref_Ne,5), new.growth = 0, migr.mat = nomig_migmat)
#hist_ev2 <- fscHistEv(num.gen = preLGMparms$preLGM_t[1], newID[which(simhist[,1] > 0)], sink.deme = newID[which(simhist[,1] > 0)], prop.migrants = 0, new.sink.size = round(preLGMparms$preLGM_Ne/preLGMparms$ref_Ne,5), new.sink.growth = 0, new.mig.mat = "nomig")
#hist_ev <- rbind(hist_ev, hist_ev1, hist_ev2)
} else {
arb.preLGM.pop <- newID[which(simhist[,1] > 0)][1]
for(rem in 2:(length(which(simhist[,1] > 0))-1)) {
eventlist[[length(eventlist)+1]] <- fscEvent(event.time = preLGMparms$preLGM_t[1]-1, source = newID[which(simhist[,1] >0)][rem], sink = arb.preLGM.pop, prop.migrants = 1, new.size = 1, new.growth = 0, migr.mat = nomig_migmat)
}
eventlist[[length(eventlist)+1]] <- fscEvent(event.time = preLGMparms$preLGM_t[1], source = arb.preLGM.pop, sink = arb.preLGM.pop, prop.migrants = 0, new.size = round(preLGMparms$preLGM_Ne/preLGMparms$ref_Ne,5), new.growth = 0, migr.mat = nomig_migmat)
#hist_ev2 <- fscHistEv(num.gen = preLGMparms$preLGM_t[1]-1, source.deme = newID[which(simhist[,1] > 0)][-1], sink.deme = arb.preLGM.pop, prop.migrants = 1, new.sink.size = 1, new.sink.growth = 0, new.mig.mat = "nomig")
#hist_ev3 <- fscHistEv(num.gen = preLGMparms$preLGM_t[1], source.deme = arb.preLGM.pop, sink.deme = arb.preLGM.pop, prop.migrants = 0, new.sink.size = round(preLGMparms$preLGM_Ne/preLGMparms$ref_Ne,5), new.sink.growth = 0, new.mig.mat = "nomig")
#hist_ev <- rbind(hist_ev, hist_ev1, hist_ev2, hist_ev3)
}
events <- do.call(fscSettingsEvents, eventlist)
###!### This is new!!
p <- fscWrite(demes = demes, genetics = genetics, events = events, migration = migration, label = label, use.wd = TRUE)
p <- fscRun(p, all.sites = FALSE, inf.sites = FALSE, no.arl.output = FALSE, dna.to.snp = TRUE, quiet = FALSE, num.cores = num_cores, exec = exec)
